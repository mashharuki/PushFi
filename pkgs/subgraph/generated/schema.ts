// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Attack extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Attack entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Attack must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Attack", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Attack | null {
    return changetype<Attack | null>(store.get("Attack", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get gameId(): BigInt {
    let value = this.get("gameId");
    return value!.toBigInt();
  }

  set gameId(value: BigInt) {
    this.set("gameId", Value.fromBigInt(value));
  }

  get result(): string {
    let value = this.get("result");
    return value!.toString();
  }

  set result(value: string) {
    this.set("result", Value.fromString(value));
  }

  get attack(): BigInt {
    let value = this.get("attack");
    return value!.toBigInt();
  }

  set attack(value: BigInt) {
    this.set("attack", Value.fromBigInt(value));
  }

  get pushCount(): BigInt {
    let value = this.get("pushCount");
    return value!.toBigInt();
  }

  set pushCount(value: BigInt) {
    this.set("pushCount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ChangeEnemyImgUrl extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ChangeEnemyImgUrl entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ChangeEnemyImgUrl must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangeEnemyImgUrl", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): ChangeEnemyImgUrl | null {
    return changetype<ChangeEnemyImgUrl | null>(
      store.get("ChangeEnemyImgUrl", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get oldEnemyUrl(): string {
    let value = this.get("oldEnemyUrl");
    return value!.toString();
  }

  set oldEnemyUrl(value: string) {
    this.set("oldEnemyUrl", Value.fromString(value));
  }

  get newEnemyUrl(): string {
    let value = this.get("newEnemyUrl");
    return value!.toString();
  }

  set newEnemyUrl(value: string) {
    this.set("newEnemyUrl", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ChangeNormalNftAddress extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ChangeNormalNftAddress entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ChangeNormalNftAddress must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangeNormalNftAddress", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): ChangeNormalNftAddress | null {
    return changetype<ChangeNormalNftAddress | null>(
      store.get("ChangeNormalNftAddress", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get oldNormalNftAddress(): Bytes {
    let value = this.get("oldNormalNftAddress");
    return value!.toBytes();
  }

  set oldNormalNftAddress(value: Bytes) {
    this.set("oldNormalNftAddress", Value.fromBytes(value));
  }

  get newNormalNftAddress(): Bytes {
    let value = this.get("newNormalNftAddress");
    return value!.toBytes();
  }

  set newNormalNftAddress(value: Bytes) {
    this.set("newNormalNftAddress", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ChangeSuperNftAddress extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ChangeSuperNftAddress entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ChangeSuperNftAddress must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ChangeSuperNftAddress", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): ChangeSuperNftAddress | null {
    return changetype<ChangeSuperNftAddress | null>(
      store.get("ChangeSuperNftAddress", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get oldSuperNftAddress(): Bytes {
    let value = this.get("oldSuperNftAddress");
    return value!.toBytes();
  }

  set oldSuperNftAddress(value: Bytes) {
    this.set("oldSuperNftAddress", Value.fromBytes(value));
  }

  get newSuperNftAddress(): Bytes {
    let value = this.get("newSuperNftAddress");
    return value!.toBytes();
  }

  set newSuperNftAddress(value: Bytes) {
    this.set("newSuperNftAddress", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Deposited extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Deposited entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Deposited must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Deposited", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Deposited | null {
    return changetype<Deposited | null>(
      store.get("Deposited", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get payee(): Bytes {
    let value = this.get("payee");
    return value!.toBytes();
  }

  set payee(value: Bytes) {
    this.set("payee", Value.fromBytes(value));
  }

  get weiAmount(): BigInt {
    let value = this.get("weiAmount");
    return value!.toBigInt();
  }

  set weiAmount(value: BigInt) {
    this.set("weiAmount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GameCreated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GameCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type GameCreated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GameCreated", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): GameCreated | null {
    return changetype<GameCreated | null>(
      store.get("GameCreated", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get gameName(): string {
    let value = this.get("gameName");
    return value!.toString();
  }

  set gameName(value: string) {
    this.set("gameName", Value.fromString(value));
  }

  get gameSeacon(): BigInt {
    let value = this.get("gameSeacon");
    return value!.toBigInt();
  }

  set gameSeacon(value: BigInt) {
    this.set("gameSeacon", Value.fromBigInt(value));
  }

  get openingStatus(): boolean {
    let value = this.get("openingStatus");
    return value!.toBoolean();
  }

  set openingStatus(value: boolean) {
    this.set("openingStatus", Value.fromBoolean(value));
  }

  get normalNftAddress(): Bytes {
    let value = this.get("normalNftAddress");
    return value!.toBytes();
  }

  set normalNftAddress(value: Bytes) {
    this.set("normalNftAddress", Value.fromBytes(value));
  }

  get superNftAddress(): Bytes {
    let value = this.get("superNftAddress");
    return value!.toBytes();
  }

  set superNftAddress(value: Bytes) {
    this.set("superNftAddress", Value.fromBytes(value));
  }

  get cardNftAddress(): Bytes {
    let value = this.get("cardNftAddress");
    return value!.toBytes();
  }

  set cardNftAddress(value: Bytes) {
    this.set("cardNftAddress", Value.fromBytes(value));
  }

  get cardNftSupply(): BigInt {
    let value = this.get("cardNftSupply");
    return value!.toBigInt();
  }

  set cardNftSupply(value: BigInt) {
    this.set("cardNftSupply", Value.fromBigInt(value));
  }

  get currentSupply(): BigInt {
    let value = this.get("currentSupply");
    return value!.toBigInt();
  }

  set currentSupply(value: BigInt) {
    this.set("currentSupply", Value.fromBigInt(value));
  }

  get winner(): Bytes {
    let value = this.get("winner");
    return value!.toBytes();
  }

  set winner(value: Bytes) {
    this.set("winner", Value.fromBytes(value));
  }

  get enemyInfo_enemyImgUrl(): string {
    let value = this.get("enemyInfo_enemyImgUrl");
    return value!.toString();
  }

  set enemyInfo_enemyImgUrl(value: string) {
    this.set("enemyInfo_enemyImgUrl", Value.fromString(value));
  }

  get enemyInfo_enemyLife(): BigInt {
    let value = this.get("enemyInfo_enemyLife");
    return value!.toBigInt();
  }

  set enemyInfo_enemyLife(value: BigInt) {
    this.set("enemyInfo_enemyLife", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GameFinished extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GameFinished entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type GameFinished must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GameFinished", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): GameFinished | null {
    return changetype<GameFinished | null>(
      store.get("GameFinished", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get gameId(): BigInt {
    let value = this.get("gameId");
    return value!.toBigInt();
  }

  set gameId(value: BigInt) {
    this.set("gameId", Value.fromBigInt(value));
  }

  get winner(): Bytes {
    let value = this.get("winner");
    return value!.toBytes();
  }

  set winner(value: Bytes) {
    this.set("winner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GameSeasonChanged extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save GameSeasonChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type GameSeasonChanged must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GameSeasonChanged", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): GameSeasonChanged | null {
    return changetype<GameSeasonChanged | null>(
      store.get("GameSeasonChanged", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get gameId(): BigInt {
    let value = this.get("gameId");
    return value!.toBigInt();
  }

  set gameId(value: BigInt) {
    this.set("gameId", Value.fromBigInt(value));
  }

  get season(): BigInt {
    let value = this.get("season");
    return value!.toBigInt();
  }

  set season(value: BigInt) {
    this.set("season", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class NftMinted extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NftMinted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type NftMinted must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NftMinted", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): NftMinted | null {
    return changetype<NftMinted | null>(
      store.get("NftMinted", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get gameId(): BigInt {
    let value = this.get("gameId");
    return value!.toBigInt();
  }

  set gameId(value: BigInt) {
    this.set("gameId", Value.fromBigInt(value));
  }

  get nftAddress(): Bytes {
    let value = this.get("nftAddress");
    return value!.toBytes();
  }

  set nftAddress(value: Bytes) {
    this.set("nftAddress", Value.fromBytes(value));
  }

  get player(): Bytes {
    let value = this.get("player");
    return value!.toBytes();
  }

  set player(value: Bytes) {
    this.set("player", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class OwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save OwnershipTransferred entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type OwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("OwnershipTransferred", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): OwnershipTransferred | null {
    return changetype<OwnershipTransferred | null>(
      store.get("OwnershipTransferred", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Withdraw extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Withdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Withdraw must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Withdraw", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): Withdraw | null {
    return changetype<Withdraw | null>(store.get("Withdraw", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get payee(): Bytes {
    let value = this.get("payee");
    return value!.toBytes();
  }

  set payee(value: Bytes) {
    this.set("payee", Value.fromBytes(value));
  }

  get weiAmount(): BigInt {
    let value = this.get("weiAmount");
    return value!.toBigInt();
  }

  set weiAmount(value: BigInt) {
    this.set("weiAmount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class WithdrawToken extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save WithdrawToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type WithdrawToken must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("WithdrawToken", id.toBytes().toHexString(), this);
    }
  }

  static load(id: Bytes): WithdrawToken | null {
    return changetype<WithdrawToken | null>(
      store.get("WithdrawToken", id.toHexString())
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    return value!.toBytes();
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get payee(): Bytes {
    let value = this.get("payee");
    return value!.toBytes();
  }

  set payee(value: Bytes) {
    this.set("payee", Value.fromBytes(value));
  }

  get prizeToken(): Bytes {
    let value = this.get("prizeToken");
    return value!.toBytes();
  }

  set prizeToken(value: Bytes) {
    this.set("prizeToken", Value.fromBytes(value));
  }

  get weiAmount(): BigInt {
    let value = this.get("weiAmount");
    return value!.toBigInt();
  }

  set weiAmount(value: BigInt) {
    this.set("weiAmount", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    return value!.toBigInt();
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}
